# playbooks/_derive_features.yml
#
# PURPOSE
# -------
# This playbook derives the *final* install_* feature flags for a host.
#
# It is the single place where we convert "profiles + overrides" into:
#   - install_<feature> booleans (true/false)
#   - install_<feature>_reason strings ("profile", "override:true", "default:false")
#
# WHY THIS EXISTS (Intent vs Implementation)
# -----------------------------------------
# - Hosts declare intent via profiles (env_profiles) and optional overrides.
# - The actual install implementations live elsewhere (feature task files / roles).
# - This file only decides *what should be installed*, not *how*.
#
# INPUTS (Central + explicit)
# ---------------------------
# From inventory/group_vars/all.yml:
#   - env_known_features      : list of all valid install_* flags in the system
#   - env_profiles_catalog    : mapping of profile -> list of install_* flags
#
# From host_vars (per machine):
#   - env_profiles            : list of profile names applied to this host
#
# Optional (host vars, extra-vars, or future):
#   - env_feature_overrides   : mapping { install_x: true|false }
#
# OUTPUTS
# -------
# - install_* flags for every item in env_known_features
# - install_*_reason companion vars
#
# WHY WE USE A LOOP HERE
# ----------------------
# We want derived state for *every known feature* without copy/paste drift.
# The loop is intentionally mechanical + transparent:
# - For each feature name in env_known_features (e.g. "install_mpv"):
#   - set vars["install_mpv"] = true/false
#   - set vars["install_mpv_reason"] = "profile"/"override:true"/"default:false"
#
# WHAT WE *DO NOT* DO HERE
# ------------------------
# - No per-feature logic (no special cases for specific installs)
# - No package names, no OS-specific commands, no post-install steps
#
# Those belong in feature task files / roles, not in the planning layer.
#
# PLAN SUMMARY
# ------------
# The plan summary is intentionally generic:
# - it lists enabled install_* flags and the reason they are enabled
# - it also shows env_features_from_profiles so you can see what profiles expanded to
#
# ADDING A NEW FEATURE (minimal work)
# ----------------------------------
# 1) Add install_<new> to env_known_features (and optionally add it to a profile)
# 2) Add playbooks/features/install_<new>.yml (or a role)
# 3) Add one include line to playbooks/_install_features.yml
#
# This file should not need changes when you add new install items.

# -----------------------------
# Normalise inputs
# -----------------------------

- name: Ensure env_profiles is defined
  ansible.builtin.set_fact:
    env_profiles: "{{ env_profiles | default([]) }}"

- name: Ensure env_feature_overrides is defined
  ansible.builtin.set_fact:
    env_feature_overrides: "{{ env_feature_overrides | default({}) }}"

# -----------------------------
# Fail fast: unknown profiles
# -----------------------------
# We do NOT silently ignore typos in env_profiles.
# If a host specifies a profile that isn't present in env_profiles_catalog, fail now
# with a clear message listing the unknown names.

- name: Compute unknown profiles (profiles not in env_profiles_catalog)
  ansible.builtin.set_fact:
    env_unknown_profiles: >-
      {{
        (env_profiles | default([]))
        | difference((env_profiles_catalog.keys() | list) | default([]))
      }}

- name: Fail if any unknown profiles are present
  ansible.builtin.assert:
    that:
      - env_unknown_profiles | length == 0
    fail_msg: >-
      Unknown profile(s) found in env_profiles: {{ env_unknown_profiles }}.
      Valid profiles are: {{ env_profiles_catalog.keys() | list }}.
      Fix inventory/host_vars/<host>.yml (env_profiles) or add the profile to env_profiles_catalog.

# -----------------------------
# Expand profiles -> features
# -----------------------------
# We map each profile name in env_profiles through env_profiles_catalog.
# Because we assert unknown profiles above, every profile here must exist in the catalog.

- name: Collect features enabled by profiles
  ansible.builtin.set_fact:
    env_features_from_profiles: >-
      {{
        (env_profiles | default([]))
        | map('extract', env_profiles_catalog)
        | list
        | flatten
        | unique
      }}

# -----------------------------
# Derive final install_* flags
# -----------------------------
# Precedence:
#   1) env_feature_overrides[install_x] if present
#   2) true if install_x is enabled by any profile
#   3) false otherwise
#
# Reason strings:
#   - "override:true|false"
#   - "profile"
#   - "default:false"

- name: Initialize env_feature_reasons
  ansible.builtin.set_fact:
    env_feature_reasons: {}

- name: Derive final feature flags (profiles + overrides; default=false)
  ansible.builtin.set_fact:
    "{{ item }}": >-
      {{
        (
          env_feature_overrides[item]
          if (env_feature_overrides is mapping and (item in env_feature_overrides))
          else
            (
              true
              if (item in (env_features_from_profiles | default([])))
              else
                false
            )
        )
      }}
    env_feature_reasons: >-
      {{
        env_feature_reasons
        | combine({
            item: (
              ('override:' ~ (env_feature_overrides[item] | string))
              if (env_feature_overrides is mapping and (item in env_feature_overrides))
              else
                (
                  'profile'
                  if (item in (env_features_from_profiles | default([])))
                  else
                    'default:false'
                )
            )
          }, recursive=True)
      }}
  loop: "{{ env_known_features }}"

- name: Expose per-feature reason variables (install_x_reason)
  ansible.builtin.set_fact:
    "{{ item }}_reason": "{{ env_feature_reasons[item] }}"
  loop: "{{ env_known_features }}"

# -----------------------------
# Plan summary (general, no per-feature rules)
# -----------------------------

- name: Debug install plan summary (clear + general)
  ansible.builtin.debug:
    msg:
      env_pkg_family: "{{ env_pkg_family | default('UNSET') }}"
      env_flavor: "{{ env_flavor | default('UNSET') }}"
      env_profiles: "{{ env_profiles }}"
      env_features_from_profiles: "{{ env_features_from_profiles }}"
      enabled_features: >-
        {{
          env_known_features
          | select(lambda k: (vars[k] | default(false)) | bool)
          | list
        }}
      enabled_feature_reasons: >-
        {{
          dict(
            (
              env_known_features
              | select(lambda k: (vars[k] | default(false)) | bool)
              | list
            )
            |
            zip(
              (
                env_known_features
                | select(lambda k: (vars[k] | default(false)) | bool)
                | map('regex_replace', '^(.*)$', '\\1_reason')
                | map('extract', vars)
                | list
              )
            )
          )
        }}
